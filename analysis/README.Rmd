---
title: "Mountain Rain or Snow 2020-2021 Analysis"
author: "Keith Jennings"
date: "7/26/2021"
output: github_document
---

# Introduction

The `Analysis` directory includes the processing scripts used to evaluate precipitation phase data submitted by citizen scientists taking part in *Mountain Rain or Snow*. This includes pre-processing the observations, downloading ancillary meteorological data, estimating air temperature at each observation point, and quality controlling the precipitation phase reports.

The analysis below includes observations submitted near Lake Tahoe during the 2020 and 2021 campaigns.

# Step 1: Data Pre-Processing

The `mros_cit_sci_obs_preprocess.R` script in `analysis/pre_processing` associates the following geospatial data with each observation:

-   Level II, III, and IV Ecoregions
-   US State
-   Elevation (m)

The script also formats the time data and removes all observations submitted without geolocation info.

# Step 2: Meteorological Data Download and Pre-Processing

Few of the citizen science observations are submitted near existing meteorological measurement stations, meaning we need to model the air temperature for each rain, snow, mixed data point. We do this with air temperature data from four networks:

| Network Name | URL                                                      |
|--------------|----------------------------------------------------------|
| HADS         | <https://mesonet.agron.iastate.edu/request/dcp/fe.phtml> |
| SNOTEL       | <https://wcc.sc.egov.usda.gov/reportGenerator/>          |
| RAWS         | <https://raws.dri.edu/>                                  |
| NCDC LCD     | <https://gis.ncdc.noaa.gov/maps/ncei/lcd>                |

The two intial datasets can be accessed programatically using `analysis/download/data_download_hads.R` and `analysis/download/data_download_snotel.R` while the latter two need to be downloaded manually from the links. After downloading the data, we prepare them for the temperature model using `analysis/pre_processing/mros_met_data_preprocess.R`.

# Step 3: Air Temperature Modeling

We then model the air temperature at each location using four methods in the `analysis/met_modeling/mros_air_temperature_model.R` script:

-   Inverse distance weighting (IDW), plus a constant lapse rate of -0.005°C/m
-   IDW, plus a variable lapse rate computed from air temperature observations
-   Nearest met station, plus a constant lapse rate of -0.005°C/m
-   Nearest met station, plus a variable lapse rate computed from air temperature observations

As a result of its higher performance in terms of mean bias and r<sup>2</sup>, we use the IDW plus variable lapse rate method when assigning air temperature to each observation point.

Future versions of the code will model additional meteorological variables, such as relative humidity, dew point temperature, and wet bulb temperature.

# Step 4: Quality Control of Citizen Science Observations

Next, we flag observations based on five criteria:

1.  Whether precipitation was recorded that day at the nearby NCDC LCD met stations.
2.  The estimated air temperature relative to realistic values for rain and snow.
3.  The relative humidity at the observation point
4.  Average distance from the met stations.
5.  If the timestamp was a duplicate of an observation from the same observer.

We then output the processed, quality controlled observations to a shareable data file: `data/processed/mros_obs_processed_2020_2021.RDS`

# Looking at the data

Now we can examine the data more in depth. First, we'll start an R session and import the file:

```{r message = FALSE}
# Load the tidyverse
library(tidyverse)

# Use cowplot for plot formatting and import plot styles
library(cowplot); theme_set(theme_cowplot())
source("functions/mros_plot_formats.R")

# Lubridate for date handling tools
library(lubridate)

# Import data
obs <- readRDS("../data/processed/mros_obs_processed_2020_2021.RDS")

# Add factor level to phase to force Rain > Mixed > Snow order
obs <- obs %>% mutate(phase = factor(phase, levels = c("Rain", "Mixed", "Snow")))
```

Within the `obs` file we have a total of `r length(obs$phase)` observations submitted between `r min(obs$date)` and `r max(obs$date)` in the Lake Tahoe area. Of these `r length(obs$phase)` observations, `r length(filter(obs, tair_flag == "Pass" & ppt_flag == "Pass" & rh_flag == "Pass" & dist_flag == "Pass" & dupe_flag == "Pass")$phase)` passed all of the quality control checks (this is `r round(length(filter(obs, tair_flag == "Pass" & ppt_flag == "Pass" & rh_flag == "Pass" & dist_flag == "Pass" & dupe_flag == "Pass")$phase)/length(obs$phase) * 100, digits = 1)`% of the database).

For the rest of document, we'll evaluate only data that passed the QC checks. We'll also add elevation bins for additional analyses

```{r message = FALSE}
# Filter to passing obs
obsPass <- filter(obs, tair_flag == "Pass" & 
                        ppt_flag == "Pass" & 
                        rh_flag == "Pass" &
                        dist_flag == "Pass" & 
                        dupe_flag == "Pass")

# Add elevation info
obsPass <- obsPass %>% 
   mutate(elev_bin = cut_width(elev, width = 500))

# Summarize by day
obsDaily <- obsPass %>% group_by(date) %>% summarize(n = n(), snow_pct = sum(phase == "Snow")/n() * 100, rain_pct = sum(phase == "Rain")/n() * 100, mixed_pct = sum(phase == "Mixed")/n() * 100 )
```

## Observations by elevation

We received precipitation reports in the study area between `r min(obsPass$elev)` m and `r max(obsPass$elev)` m, with mean and median report elevations of `r round(mean(obsPass$elev), digits = 0)` m and `r round(median(obsPass$elev), digits = 0)` m, respectively. In total, there were `r length(filter(obsPass, phase == "Snow")$phase)`, `r length(filter(obsPass, phase == "Rain")$phase)`, `r length(filter(obsPass, phase == "Mixed")$phase)`, snow, rain, and mixed observations.

The elevational breakdown of precipitation phase looks like this:

```{r echo = FALSE}
ggplot(obsPass, aes(elev_bin, fill = phase)) +
  geom_bar(position = "fill", color = "black") +
  phase_fill_scale +
  labs(x = "Elevation Bin (m)",
       y = "Type Proportion (%)") +
  scale_y_continuous(breaks = seq(0, 1, by = 0.25),
                     labels = c("0", "25", "50", "75", "100")) +
  scale_x_discrete(labels = c("< 1250",
                              "1250 - 1750",
                              "1750 - 2250",
                              "> 2250"))
```

Similarly, we can look at the number of reports per precipitation phase by elevation:

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,6)}
ggplot(obsPass, aes(elev, fill = phase)) + 
  geom_histogram(color = "black") + 
  facet_wrap(~phase) + 
  coord_flip() + 
  phase_fill_scale +
  labs(y = "Number of Observations", 
       x = "Elevation (m)") +
  theme(strip.background = element_rect(fill = "white", color = "black"),
        legend.position = "none")
```

Or grouped together:

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,6)}
ggplot(obsPass, aes(elev, fill = phase)) + 
  geom_histogram(color = "black") + 
  coord_flip() + 
  phase_fill_scale +
  labs(y = "Number of Observations", 
       x = "Elevation (m)") +
  theme(strip.background = element_rect(fill = "white", color = "black"),
        legend.position = c(0.8, 0.8))
```

## Observations by state and ecoregion

Across the study period, we had the following geographic breakdown of observations.

By state:

```{r echo = FALSE, warning = FALSE, message = FALSE}
obsPass %>% 
  group_by(state) %>% 
  summarise(n = n()) %>% 
  knitr::kable()
```

By US EPA Level III Ecoregion:

```{r echo = FALSE, warning = FALSE, message = FALSE}
obsPass %>% 
  group_by(eco_l3) %>% 
  summarise(n = n()) %>% 
  knitr::kable()
```

And by US EPA Level IV Ecoregion:

```{r echo = FALSE, warning = FALSE, message = FALSE}
obsPass %>% 
  group_by(eco_l4) %>% 
  summarise(n = n()) %>% 
  knitr::kable()
```

## Observations by year

Our *Tahoe Rain or Snow* study period comprised two water years: 2020 and 2021.

```{r message = FALSE}
# Add water year info
obsPass <- obsPass %>% 
   mutate(wy = ifelse(month(date) >= 10,
                      year(date) + 1,
                      year(date)),
          dowy = ifelse(month(date) >= 10,
                        yday(date) - 273,
                        yday(date) + 92))

# Compute cumulative observations per phase and water year
obsPass <- obsPass %>% 
  arrange(date) %>% 
  group_by(wy, phase) %>% 
  mutate(n_cumulative = row_number())
```

We received `r length(filter(obsPass, wy == 2020)$phase)` observations in water year 2020 and `r length(filter(obsPass, wy == 2021)$phase)` in 2021. Snow was the most frequent phase in both water years, but both rain and mixed precipitation increased in relative proportion in 2021.

```{r echo = FALSE, warning = FALSE, message = FALSE}
obsPass %>% 
  group_by(wy, phase) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  group_by(wy) %>% 
  mutate(pct = round(n / sum(n) * 100, digits = 1)) %>% 
  knitr::kable()
```

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,4)}
ggplot(obsPass, aes(dowy, n_cumulative, color = phase)) + 
  geom_line(lwd = 1) + 
  labs(x = "Date",
       y = "Cumulative Observations") +
  theme(legend.position = c(0.1, 0.9), legend.title = element_blank(),
        strip.background = element_rect(fill = NA, color = "black")) +
  scale_color_manual(values = c("blue", "purple", "black")) +
  facet_wrap(~wy, ncol = 1) +
  scale_x_continuous(breaks = c(1, 93, 183, 274), 
                     labels = c("Oct. 1", "Jan. 1", "Apr. 1", "Jul. 1"))
```

## Observations by air temperature

According to modeled air temperature data, volunteers submitted precipitation phase reports from a minimum air temperature value of `r round(min(obsPass$tair), digits = 1)`°C to a maximum of `r round(max(obsPass$tair), digits = 1)`°C with a median value of `r round(median(obsPass$tair), digits = 1)`°C. The vast majority of reports came from a relatively narrow air temperature range. Our data show 95% of observations corresponded to air temperatures between `r round(quantile(obsPass$tair, probs = c(0.025, 0.975))[1], digits = 1)`°C and `r round(quantile(obsPass$tair, probs = c(0.025, 0.975))[2], digits = 1)`°C. `r round(sum(obsPass$tair >= 0 & obsPass$tair <= 4)/length(obsPass$tair) * 100, 1)`% of reported precipitation fell between 0°C and 4°C, the air temperature range identified by previous research to have the greatest rain-snow partitioning uncertainty. 

```{r echo = FALSE, warning = FALSE, message = FALSE}
# Compute a whole mess of distributions and their overlaps

# By tair
tair_snowDens <- with(obsPass, density(tair[phase == "Snow"], 
                           from = min(tair), 
                           to = max(tair)))
tair_rainDens <- with(obsPass, density(tair[phase == "Rain"], 
                           from = min(tair),
                           to = max(tair)))
tair_mixDens <- with(obsPass, density(tair[phase == "Mixed"], 
                                from = min(tair),
                                to = max(tair)))
tair_snowRain_joint <- pmin(tair_snowDens$y, tair_rainDens$y)
tair_snowRain_overlap = (sum(tair_snowRain_joint)/sum(tair_snowDens$y) +
                           sum(tair_snowRain_joint)/sum(tair_rainDens$y))/2
tair_snowMix_joint <- pmin(tair_snowDens$y, tair_mixDens$y)
tair_snowMix_overlap = (sum(tair_snowMix_joint)/sum(tair_snowDens$y) +
                           sum(tair_snowMix_joint)/sum(tair_mixDens$y))/2
tair_rainMix_joint <- pmin(tair_rainDens$y, tair_mixDens$y)
tair_rainMix_overlap = (sum(tair_rainMix_joint)/sum(tair_rainDens$y) +
                           sum(tair_rainMix_joint)/sum(tair_mixDens$y))/2
tair_all_joint <- pmin(tair_rainDens$y, tair_mixDens$y, tair_snowDens$y)
tair_all_overlap = (sum(tair_all_joint)/sum(tair_rainDens$y) +
                      sum(tair_all_joint)/sum(tair_mixDens$y) +
                      sum(tair_all_joint)/sum(tair_snowDens$y))/3

# By twet
twet_snowDens <- with(obsPass, density(twet[phase == "Snow"], 
                           from = min(twet), 
                           to = max(twet)))
twet_rainDens <- with(obsPass, density(twet[phase == "Rain"], 
                           from = min(twet),
                           to = max(twet)))
twet_mixDens <- with(obsPass, density(twet[phase == "Mixed"], 
                                from = min(twet),
                                to = max(twet)))
twet_snowRain_joint <- pmin(twet_snowDens$y, twet_rainDens$y)
twet_snowRain_overlap = (sum(twet_snowRain_joint)/sum(twet_snowDens$y) +
                           sum(twet_snowRain_joint)/sum(twet_rainDens$y))/2
twet_snowMix_joint <- pmin(twet_snowDens$y, twet_mixDens$y)
twet_snowMix_overlap = (sum(twet_snowMix_joint)/sum(twet_snowDens$y) +
                           sum(twet_snowMix_joint)/sum(twet_mixDens$y))/2
twet_rainMix_joint <- pmin(twet_rainDens$y, twet_mixDens$y)
twet_rainMix_overlap = (sum(twet_rainMix_joint)/sum(twet_rainDens$y) +
                           sum(twet_rainMix_joint)/sum(twet_mixDens$y))/2
twet_all_joint <- pmin(twet_rainDens$y, twet_mixDens$y, twet_snowDens$y)
twet_all_overlap = (sum(twet_all_joint)/sum(twet_rainDens$y) +
                      sum(twet_all_joint)/sum(twet_mixDens$y) +
                      sum(twet_all_joint)/sum(twet_snowDens$y))/3

# By tdew
tdew_snowDens <- with(obsPass, density(tdew[phase == "Snow"], 
                           from = min(tdew), 
                           to = max(tdew)))
tdew_rainDens <- with(obsPass, density(tdew[phase == "Rain"], 
                           from = min(tdew),
                           to = max(tdew)))
tdew_mixDens <- with(obsPass, density(tdew[phase == "Mixed"], 
                                from = min(tdew),
                                to = max(tdew)))
tdew_snowRain_joint <- pmin(tdew_snowDens$y, tdew_rainDens$y)
tdew_snowRain_overlap = (sum(tdew_snowRain_joint)/sum(tdew_snowDens$y) +
                           sum(tdew_snowRain_joint)/sum(tdew_rainDens$y))/2
tdew_snowMix_joint <- pmin(tdew_snowDens$y, tdew_mixDens$y)
tdew_snowMix_overlap = (sum(tdew_snowMix_joint)/sum(tdew_snowDens$y) +
                           sum(tdew_snowMix_joint)/sum(tdew_mixDens$y))/2
tdew_rainMix_joint <- pmin(tdew_rainDens$y, tdew_mixDens$y)
tdew_rainMix_overlap = (sum(tdew_rainMix_joint)/sum(tdew_rainDens$y) +
                           sum(tdew_rainMix_joint)/sum(tdew_mixDens$y))/2
tdew_all_joint <- pmin(tdew_rainDens$y, tdew_mixDens$y, tdew_snowDens$y)
tdew_all_overlap = (sum(tdew_all_joint)/sum(tdew_rainDens$y) +
                      sum(tdew_all_joint)/sum(tdew_mixDens$y) +
                      sum(tdew_all_joint)/sum(tdew_snowDens$y))/3
```

We also found marked overlap in the phase distributions by temperature, underscoring the difficulty in using near-surface meteorological data to partition rain, snow, and mixed precipitation (FIG XXXX). The distributions for rain and snow, for example, overlapped by `r round(tair_snowRain_overlap * 100, 1)`%, `r round(twet_snowRain_overlap * 100, 1)`%, and `r round(tdew_snowRain_overlap * 100, 1)`% for air, wet bulb, and dew point temperature, respectively. This suggests wet bulb temperature is a more sensitive predictor of rain versus snow relative to the other temperature types, while air temperature is the least sensitive. Air temperature also had the highest percent overlap between snow and mixed (`r round(tair_snowMix_overlap * 100, 1)`%) and rain and mixed phases (`r round(tair_rainMix_overlap * 100, 1)`%). The minimum overlap between mixed precipitation and another phase was `r round(twet_snowMix_overlap * 100, 1)`%, indicating the near-surface meteorological conditions favoring mixed precipitation are often indistinguishable from rain and snow.

```{r echo = FALSE, warning = FALSE, message = FALSE}
plot_grid(
  ggplot(obsPass, aes(tair, color = phase)) +
    geom_density(lwd = 1)+
    scale_color_manual(values = c("blue", "purple", "black")) +
    labs(x = "Air Temperature (°C)", y = "Density") +
    theme(legend.position = c(0.8,0.8), legend.title = element_blank()) +
    xlim(-15, 10),
  ggplot(obsPass, aes(twet, color = phase)) +
    geom_density(lwd = 1)+
    scale_color_manual(values = c("blue", "purple", "black")) +
    labs(x = "Wet Bulb Temperature (°C)", y = "Density") +
    theme(legend.position = "none") +
    xlim(-15, 10),
  ggplot(obsPass, aes(tdew, color = phase)) +
    geom_density(lwd = 1)+
    scale_color_manual(values = c("blue", "purple", "black")) +
    labs(x = "Dew Point Temperature (°C)", y = "Density") +
    theme(legend.position = "none") +
    xlim(-15, 10),
  cols = 1, align = "vh", labels = "auto"
)
```

## Rain-snow partitioning

Using the observations and modeled meteorological data, we can compute snowfall probability curves and 50% snowfall probability temperatures, the latter of which are used as thresholds in models to split solid and liquid precipitation. We provide a methods overview here and the full code can be found in `mros_obs_analysis.R`. In short, we bin air temperature in 1°C increments from -10°C to 20°C and wet bulb temperature in 1°C increments from -12°C to 16°C. We then compute the probability of snowfall occurring in each air and wet bulb temperature bin. Those data are next fit with a hyperbolic tangent as in Dai (2008) and Jennings et al. (2018) to create snowfall probability curves. The 50% snowfall probability air and wet bulb temperature thresholds are where the fitted curves pass the 50% mark.

Let's import the data.

```{r message = FALSE}

# Import data
rs_p <- readRDS("../data/processed/mros_obs_rs_partitioning_2020_2021.RDS")

```

We can then look at the air temperature snowfall probability plot:

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,4)}
ggplot(rs_p[["snow_pred_tair"]], aes(tair_bin_num, snow_prob_pred * 100)) + 
  geom_line(lwd = 1) + 
  geom_hline(yintercept = 50, color = "gray", lty = "dashed", lwd = 1) +
  geom_line(data = rs_p[["snow_prob_tair"]], aes(tair_bin_num, snow_prob * 100), 
             color = "darkgreen", lwd = 1) +
  labs(x = expression("Air Temperature ("*degree*C*")"),
       y = "Snowfall Probability (%)") +
  annotate(geom = "text", x = -8, y = 25, label = "Fitted curve", hjust = 0) +
  annotate(geom = "text", x = -8, y = 15, label = "Probability by bin", color = "darkgreen", hjust = 0) +
  annotate(geom = "text", x = 10, y = 50, label = paste0("50% probability = ", round(rs_p[["temp50_tair"]], digits = 1), "°C"), 
           color = "gray27", hjust = 0, vjust = -.5)
```

The wet bulb temperature snowfall probability plot:

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,4)}
ggplot(rs_p[["snow_pred_twet"]], aes(twet_bin_num, snow_prob_pred * 100)) + 
  geom_line(lwd = 1) + 
  geom_hline(yintercept = 50, color = "gray", lty = "dashed", lwd = 1) +
  geom_line(data = rs_p[["snow_prob_twet"]], aes(twet_bin_num, snow_prob * 100), 
             color = "aquamarine3", lwd = 1) +
  labs(x = expression("Wet Bulb Temperature ("*degree*C*")"),
       y = "Snowfall Probability (%)") +
  annotate(geom = "text", x = -10, y = 25, label = "Fitted curve", hjust = 0) +
  annotate(geom = "text", x = -10, y = 15, label = "Probability by bin", color = "aquamarine3", hjust = 0) +
  annotate(geom = "text", x = 6, y = 50, label = paste0("50% probability = ", round(rs_p[["temp50_twet"]], digits = 1), "°C"), 
           color = "gray27", hjust = 0, vjust = -.5)
```

The dew point temperature snowfall probability plot:

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,4)}
ggplot(rs_p[["snow_pred_tdew"]], aes(tdew_bin_num, snow_prob_pred * 100)) + 
  geom_line(lwd = 1) + 
  geom_hline(yintercept = 50, color = "gray", lty = "dashed", lwd = 1) +
  geom_line(data = rs_p[["snow_prob_tdew"]], aes(tdew_bin_num, snow_prob * 100), 
             color = "darkolivegreen3", lwd = 1) +
  labs(x = expression("Dew Point Temperature ("*degree*C*")"),
       y = "Snowfall Probability (%)") +
  annotate(geom = "text", x = -10, y = 25, label = "Fitted curve", hjust = 0) +
  annotate(geom = "text", x = -10, y = 15, label = "Probability by bin", color = "darkolivegreen3", hjust = 0) +
  annotate(geom = "text", x = 6, y = 50, label = paste0("50% probability = ", round(rs_p[["temp50_tdew"]], digits = 1), "°C"), 
           color = "gray27", hjust = 0, vjust = -.5)
```

And the three of them combined:

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,4)}
ggplot() + 
  geom_hline(yintercept = 50, color = "gray", lty = "dashed", lwd = 1) +
  geom_line(data = rs_p[["snow_prob_tair"]], aes(tair_bin_num, snow_prob * 100), 
             color = "darkgreen", lwd = 1) +
  geom_line(data = rs_p[["snow_prob_twet"]], aes(twet_bin_num, snow_prob * 100), 
             color = "aquamarine3", lwd = 1) +
   geom_line(data = rs_p[["snow_prob_tdew"]], aes(tdew_bin_num, snow_prob * 100), 
             color = "darkolivegreen3", lwd = 1) +
  labs(x = expression("Temperature ("*degree*C*")"),
       y = "Snowfall Probability (%)") +
  annotate(geom = "text", x = -10, y = 25, label = "Air temperature", color = "darkgreen", hjust = 0) +
  annotate(geom = "text", x = -10, y = 15, label = "Wet bulb temperature", color = "aquamarine3", hjust = 0)+
  annotate(geom = "text", x = -10, y = 5, label = "Dew point temperature", color = "darkolivegreen3", hjust = 0)
```

When evaluating snowfall probability from the crowdsourced data by air, wet bulb, and dew point temperature, we see the expected reverse sigmoid curve (Fig. XXXX). In all cases probability is near 100% for the coldest temperatures before decreasing as temperature warms. There are two noticeable features of the air temperature curves: 1) the observed curve has a greater amount of noise than the curves for wet bulb and dew point temperature and 2) the fitted probability curve has a shallower gradient near 50%, confirming the metric's reduced sensitivity to rain-snow partitioning. The 50% snowfall probability thresholds derived from hyperbolic tangent curves fit to the citizen science data are `r round(rs_p[["temp50_tair"]], 1)`°C, `r round(rs_p[["temp50_twet"]], 1)`°C, and `r round(rs_p[["temp50_tdew"]], 1)`°C for air, wet bulb, and dew point temperature, respectively. We expect threshold values to follow this trend as T<sub>dew</sub> < T<sub>wet</sub> < T<sub>air</sub> when relative humidity is less than 100%. 

```{r echo = FALSE, warning = FALSE, message = FALSE}
# Bind the data into long form for easier plotting
rs_p_df <- bind_rows(
  rs_p[["snow_prob_tair"]] %>% rename(temp_val = tair_bin_num) %>%
    mutate(temp_type = "tair", eval_type = "obs"),
  rs_p[["snow_pred_tair"]] %>% rename(temp_val = tair_bin_num, snow_prob = snow_prob_pred) %>%
    mutate(temp_type = "tair", eval_type = "sim"),
  rs_p[["snow_prob_twet"]] %>% rename(temp_val = twet_bin_num) %>%
    mutate(temp_type = "twet", eval_type = "obs"),
  rs_p[["snow_pred_twet"]] %>% rename(temp_val = twet_bin_num, snow_prob = snow_prob_pred) %>%
    mutate(temp_type = "twet", eval_type = "sim"),
  rs_p[["snow_prob_tdew"]] %>% rename(temp_val = tdew_bin_num) %>%
    mutate(temp_type = "tdew", eval_type = "obs"),
  rs_p[["snow_pred_tdew"]] %>% rename(temp_val = tdew_bin_num, snow_prob = snow_prob_pred) %>%
    mutate(temp_type = "tdew", eval_type = "sim")
) %>% 
  mutate(temp_type = factor(temp_type, levels = c("tair", "twet", "tdew")))
```

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,4)}
ggplot() + 
  geom_hline(yintercept = 50, color = "gray", lty = "dashed", lwd = 1) +
  geom_line(data = rs_p_df, aes(temp_val, snow_prob * 100, color = temp_type, lty = eval_type),
            lwd = 1) +
  scale_color_manual(values = c("darkgreen", "aquamarine3", "darkolivegreen3"),
                     labels = c(expression(T[air]), expression(T[wet]), expression(T[dew])),
                     name = "Temperature") +
  scale_linetype_discrete(labels = c("Observed", "Fitted"),
                     name = "Data Source") +
  labs(x = expression("Temperature ("*degree*C*")"),
       y = "Snowfall Probability (%)") + 
  theme(legend.text.align = 0)
```

```{r echo = FALSE, warning = FALSE, message = FALSE}
tmp <- filter(obsPass, tair >= min(filter(rs_p[["snow_prob_tair"]],snow_prob <= .50 & snow_prob >= .25)$tair_bin_num) &
                tair <= max(filter(rs_p[["snow_prob_tair"]],snow_prob <= .50 & snow_prob >= .25)$tair_bin_num))
rs_hum <- tmp %>% 
  group_by(phase) %>% 
  summarise("mean_rh" = mean(rh)) %>% 
  mutate(temp = "air")
tmp <- filter(obsPass, twet >= min(filter(rs_p[["snow_prob_twet"]],snow_prob <= .50 & snow_prob >= .25)$twet_bin_num, na.rm = T) &
                twet <= max(filter(rs_p[["snow_prob_twet"]],snow_prob <= .50 & snow_prob >= .25)$twet_bin_num, na.rm = T))

rs_hum <- bind_rows(
  rs_hum,
  tmp %>% 
  group_by(phase) %>% 
  summarise("mean_rh" = mean(rh)) %>% 
  mutate(temp = "wet bulb"))

knitr::kable(rs_hum)

```

## 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,3)}
p <- ggplot(filter(obsPass, phase == "Snow"), aes(tair)) + geom_density(fill = "gray") +
  labs(x = "Air Temperature (°C)", y = "Density")
p
# Get the density data from the plot
# This will allow us to look at right/wrong values
d <- ggplot_build(p)$data[[1]]
```

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,3)}
tair_thresh = 0
pct_incorrect = length(filter(obsPass, tair>tair_thresh & phase == "Snow")$phase) /length(filter(obsPass, phase == "Snow")$phase) * 100
p +  geom_area(data = filter(d, x>tair_thresh), aes(x=x,y=y), fill = "darkred", alpha = 0.5) +
  annotate(geom = "text", x = 2.5, y = 0.1, 
           label = paste0(round(pct_incorrect, digits = 1), "% of snow misidentified"), color = "darkred",
           hjust = 0)
```

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,3)}
tair_thresh = 2.2
pct_incorrect = length(filter(obsPass, tair>tair_thresh & phase == "Snow")$phase) /length(filter(obsPass, phase == "Snow")$phase) * 100
p +  geom_area(data = filter(d, x>tair_thresh), aes(x=x,y=y), fill = "darkred", alpha = 0.5) +
  annotate(geom = "text", x = 2.5, y = 0.1, 
           label = paste0(round(pct_incorrect, digits = 1), "% of snow misidentified"), color = "darkred",
           hjust = 0)
```

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,3)}
tair_thresh = 3.9
pct_incorrect = length(filter(obsPass, tair>tair_thresh & phase == "Snow")$phase) /length(filter(obsPass, phase == "Snow")$phase) * 100
p +  geom_area(data = filter(d, x>tair_thresh), aes(x=x,y=y), fill = "darkred", alpha = 0.5) +
  annotate(geom = "text", x = 2.5, y = 0.1, 
           label = paste0(round(pct_incorrect, digits = 1), "% of snow misidentified"), color = "darkred",
           hjust = 0)
```
## Rain-snow lines from the citizen science data
```{r message = FALSE}
# Import processed rain-snow line data
rain_snow_line <- readRDS("../data/processed/mros_obs_rain_snow_line_2020-2021.RDS")

# Import the probabilities by elevation bin
rain_snow_prob_elev <- readRDS("../data/processed/mros_obs_rain_snow_prob_elev_2020-2021.RDS")

# Get valid dates from data
valid_dates = filter(rain_snow_line, note == "valid" &
                       n >= 10 &
                       rs_line <= max(obsPass$elev) &
                       rs_line >= min(obsPass$elev))$date

# Plot
ggplot(filter(rain_snow_prob_elev, date %in% valid_dates), 
       aes(snow_prob, elev)) + 
  geom_point() + 
  geom_hline(data = filter(rain_snow_line, date %in% valid_dates), aes(yintercept = rs_line)) + 
  facet_wrap(~date) 
```
During the study period, we had `r length(valid_dates)` days when we could estimate a valid rain-snow line elevation from the citizen science data. We did not consider values above the maximum or below the minimum observation elevation to be valid. That means of the `r length(filter(obsDaily, n >= 10)$date)` days with at least 10 observations, we could compute daily rain-snow lines on `r round(length(valid_dates) / length(filter(obsDaily, n >= 10)$date) * 100, 1)`% of them. There were `r length(filter(rain_snow_line, note == "above" & n >= 10)$date)` days when the maximum snowfall probability was less than 50% and `r length(filter(rain_snow_line, note == "below" & n >= 10)$date)` days when the minimum was above 50%. In these cases we would estimate the rain-line elevation to be above or below the study domain, respectively, indicating rain or snow dominance. On days with valid values, daily rain-snow line elevations ranged from a minimum of `r round(min(filter(rain_snow_line, date %in% valid_dates)$rs_line), 0)` m to a maximum of `r round(max(filter(rain_snow_line, date %in% valid_dates)$rs_line), 0)` m, with a median value of `r round(median(filter(rain_snow_line, date %in% valid_dates)$rs_line), 0)` m.

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(4,4)}
ggplot(filter(rain_snow_line, date %in% valid_dates), aes(rs_line)) + 
  geom_histogram(fill = "lavender", color = "black", binwidth = 50) + 
  coord_flip() +
  labs(x = "Daily Rain-Snow Line Elevation (m)", y = "Count")
```

Instances of valid daily rain-snow line estimates occurring in succession where relatively rare during our study period. 

## Precipitation phase partitioning method comparison

Import the summary data produced in `analysis/rain_snow/mros_method_comparison.R`

```{r message = FALSE}
# import the summary and summary by tair data
method_summary <- readRDS("../data/processed/mros_obs_sim_summary.RDS") %>% 
  filter(scenario != "thresh_tair_0" & scenario != "thresh_tair_0.5")
method_summary_byTair <- readRDS("../data/processed/mros_obs_sim_summary_byTair.RDS") %>% 
  filter(scenario != "thresh_tair_0" & scenario != "thresh_tair_0.5")
```

```{r echo = FALSE, warning = FALSE, message = FALSE}
# Compute a bunch of values for analysis text
snowPct_obs = round(sum(obsPass$phase == "Snow") / length(obsPass$phase) * 100, 1)
rainPct_obs = round(sum(obsPass$phase == "Rain") / length(obsPass$phase) * 100, 1)
mixedPct_obs = round(sum(obsPass$phase == "Mixed") / length(obsPass$phase) * 100, 1)

methSummary <- method_summary %>% 
  group_by(eval_type) %>% 
  summarize(snowPct_sim_av = mean(snow_pct * (1 + snow_bias_pct/100)),
            snowPct_sim_sd = sd(snow_pct * (1 + snow_bias_pct/100)),
            snowPct_sim_min = min(snow_pct * (1 + snow_bias_pct/100)),
            snowPct_sim_max = max(snow_pct * (1 + snow_bias_pct/100)),
            rainPct_sim_av = mean(rain_pct * (1 + rain_bias_pct/100)),
            rainPct_sim_sd = sd(rain_pct * (1 + rain_bias_pct/100)),
            rainPct_sim_min = min(rain_pct * (1 + rain_bias_pct/100)),
            rainPct_sim_max = max(rain_pct * (1 + rain_bias_pct/100)),
            mixedPct_sim_av = mean(mixed_pct * (1 + mixed_bias_pct/100), na.rm = T),
            mixedPct_sim_sd = sd(mixed_pct * (1 + mixed_bias_pct/100), na.rm = T),
            mixedPct_sim_min = min(mixed_pct * (1 + mixed_bias_pct/100), na.rm = T),
            mixedPct_sim_max = max(mixed_pct * (1 + mixed_bias_pct/100), na.rm = T)) %>% 
  mutate_if(is.numeric, round, digits = 1)
```

The different precipitation phase partitioning methods applied to the modeled meteorological data produced marked variability in the predicted snow, rain, and mixed proportions relative to the observations. Over our study period, crowdsourced precipitation phase reports were comprised of `r snowPct_obs`% snow, `r rainPct_obs`% rain, and `r mixedPct_obs`% mixed. In comparison, the precipitation phase partitioning methods tended to underpredict snow and mixed precipitation, while overpredicting rain. Snowfall frequency estimates from the different methods ranged from a minimum of `r methSummary %>% filter(eval_type == "all") %>% pull(snowPct_sim_min)`% to a maximum of `r methSummary %>% filter(eval_type == "all") %>% pull(snowPct_sim_max)`%, with an average of `r methSummary %>% filter(eval_type == "all") %>% pull(snowPct_sim_av)`% and standard deviation of `r methSummary %>% filter(eval_type == "all") %>% pull(snowPct_sim_sd)`%. Rainfall frequency estimates were similarly varied, ranging from a minimum of `r methSummary %>% filter(eval_type == "all") %>% pull(rainPct_sim_min)`% to a maximum of `r methSummary %>% filter(eval_type == "all") %>% pull(rainPct_sim_max)`%, with an average of `r methSummary %>% filter(eval_type == "all") %>% pull(rainPct_sim_av)`% and standard deviation of `r methSummary %>% filter(eval_type == "all") %>% pull(rainPct_sim_sd)`%. Only the two air temperature ranges predicted mixed precipitation, with frequency estimates of 14.4% and 48.1%. The other methods do not assign mixed precipitation, bringing down the average to `r methSummary %>% filter(eval_type == "all") %>% pull(mixedPct_sim_av)`%.

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(6,4)}
method_summary_toPlot <- method_summary %>% 
  filter(eval_type == "all") %>% 
  transmute(Snow = snow_pct * (1 + snow_bias_pct/100),
         Rain = rain_pct * (1 + rain_bias_pct/100),
         Mixed = mixed_pct * (1 + mixed_bias_pct/100)) %>% 
  pivot_longer(Snow:Mixed, values_to = "percent", names_to = "phase") %>% 
  mutate(phase = factor(phase, levels = c("Rain", "Mixed", "Snow")))
obs_pct_toPlot <- data.frame(percent = c(snowPct_obs, rainPct_obs, mixedPct_obs),
                             phase = c("Snow", "Rain", "Mixed")) %>% 
  mutate(phase = factor(phase, levels = c("Rain", "Mixed", "Snow")))
ggplot(method_summary_toPlot, aes(phase, percent, fill = phase)) + 
  geom_boxplot() + 
  geom_point(data = obs_pct_toPlot, shape = 24, size = 3) +
  phase_fill_scale +
  labs(x = "Precipitation Phase", y = "Estimated Frequency (%)") +
  theme(legend.position = "none")
```

Besides the variability in the estimated frequency of the different phases, we also quantified the performance of the methods. Although refining their output was not the goal of this research, we do note some relevant results here. Method success rate, where 100% equals all precipitation phase observations correctly predicted, ranged from `r round(min(filter(method_summary, eval_type == "all")$perf_pct), 1)`% for R<sub>a1.0</sub> to `r round(max(filter(method_summary, eval_type == "all")$perf_pct), 1)`% for T<sub>d0.0</sub>. The top six methods compared to the observations all incorporated humidity in some form and, notably, none could predict mixed precipitation as they were the wet bulb and dew point thresholds along with the binary logistic regression model. This meant, in practice, the best they could perform was `r 100 - mixedPct_obs`%. Even though the range methods could predict mixed precipitation, they performed poorly overall. The best-performing air temperature method was the optimized T<sub>a4.2</sub> from our previous study. Additionally, there were no methods that had both snow and rain relative biases less than 10%. In general, the methods that had low snow biases had higher rain biases and vice versa.

For comparison sake we also reassigned mixed precipitation to be rain as in the IMERG PLP product, which only considers precipitation to be in the liquid or solid phase. Applying this assumption widened the range of method success rates, which now stretched from a minimum of `r round(min(filter(method_summary, eval_type == "mixRain")$perf_pct), 1)`% for R<sub>a1.0</sub> to `r round(max(filter(method_summary, eval_type == "mixRain")$perf_pct), 1)`% for T<sub>d0.0</sub>. Again, the top six methods were all of the ones that incorporated humidity. In this analysis, there were two methods, Bin<sub>log</sub> and T<sub>w0.5</sub>, that had rain and snow frequency relative bias magnitudes <= 10%.

```{r}
method_summary_4table <-
  left_join(filter(method_summary, eval_type == "all"),
            filter(method_summary, eval_type == "mixRain"),
                   by = "scenario") %>% 
  mutate(scenario = factor(scenario, 
                           levels=c("thresh_tair_1",
                                    "thresh_tair_1.5",
                                    "thresh_tair_1.8",
                                    "thresh_tair_1.9",
                                    "thresh_tair_2.7",
                                    "thresh_tair_4.2",
                                    "thresh_twet_0",
                                    "thresh_twet_0.5",
                                    "thresh_twet_1", 
                                    "thresh_tdew_0",
                                    "thresh_tdew_0.5",
                                    "range_tair_-0.5_0.5",
                                    "range_tair_-1_3",
                                    "binlog"))) %>% 
  arrange(scenario) %>% 
  mutate_if(is.numeric, round, digits = 1) %>% 
  as.data.frame()
rownames(method_summary_4table) <- c("T~a1.0~",
                               "T~a1.5~",
                               "T~a1.8~",
                               "T~a1.9~",
                               "T~a2.7~",
                               "T~a4.2~",
                               "T~w0.0~",
                               "T~w0.5~",
                               "T~w1.0~",
                               "T~d0.0~",
                               "T~d0.5~",
                               "R~a0.0~",
                               "R~a1.0~",
                               "Bin~log~")
method_summary_4table %>% 
  #filter(eval_type == "all" | eval_type == "mixRain") %>% 
  select(`Success Rate A` = perf_pct.x, `Snow Bias A` = snow_bias_pct.x, 
         `Rain Bias A` = rain_bias_pct.x, `Mixed Bias A` = mixed_bias_pct.x,
         `Success Rate MR` = perf_pct.y, `Snow Bias MR` = snow_bias_pct.y, 
         `Rain Bias MR` = rain_bias_pct.y, `Mixed Bias MR` = mixed_bias_pct.y) %>% 
  knitr::kable()
```

As expected, we saw method performance vary by air temperature with the lowest success rates between 0°C and 10°C. All methods could reliably predict snowfall at air temperatures below freezing, while the air temperature thresholds and ranges struggled to provide accurate snowfall predictions above 0°C. None of the methods could accurately predict freezing rain. The six methods incorporating humidity provided more consistent performance across the range of modelled air temperatures with T<sub>d0.0</sub> and T<sub>d0.5</sub> most capable of correctly predicting the snow falling at warm temperatures. However, these methods did this at the expense of underpredicting rain above 7.5°C. T<sub>d0.0</sub>, the best-performing method in both analysis cases, had a minimum success rate of `r round(min(filter(method_summary_byTair, scenario == "thresh_tdew_0" & n >= 10 & eval_type == "all")$perf_pct), 1)`% at `r filter(method_summary_byTair, scenario == "thresh_tdew_0" & n >= 10 & eval_type == "all") %>% arrange(perf_pct) %>% slice(1) %>% pull(tair_bin_num)`°C. Although concerning, it is still quantifiably better than the sub 20% minimum success rates of the air temperature range methods.

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(7,4.5)}
testLabs <- method_summary_byTair %>% 
  mutate(scenario = factor(scenario, 
                           levels=c("thresh_tair_1",
                                    "thresh_tair_1.5",
                                    "thresh_tair_1.8",
                                    "thresh_tair_1.9",
                                    "thresh_tair_2.7",
                                    "thresh_tair_4.2",
                                    "thresh_twet_0",
                                    "thresh_twet_0.5",
                                    "thresh_twet_1", 
                                    "thresh_tdew_0",
                                    "thresh_tdew_0.5",
                                    "range_tair_-0.5_0.5",
                                    "range_tair_-1_3",
                                    "binlog")))
levels(testLabs$scenario) <- c("T[a1.0]",
                               "T[a1.5]",
                               "T[a1.8]",
                               "T[a1.9]",
                               "T[a2.7]",
                               "T[a4.2]",
                               "T[w0.0]",
                               "T[w0.5]",
                               "T[w1.0]",
                               "T[d0.0]",
                               "T[d0.5]",
                               "R[a0.0]",
                               "R[a1.0]",
                               "Bin[log]")
testLabs %>% 
  filter(n >= 10) %>% 
  filter(eval_type == "all" | eval_type == "mixRain") %>% 
  mutate(eval_type = ifelse(eval_type == "all", "All Obs.", "Mixed = Rain")) %>% 
  ggplot(aes(tair_bin_num, scenario, fill = perf_pct)) + 
  geom_raster() + 
  facet_wrap(~eval_type) +
  scale_fill_viridis_c(option = "plasma", name = "Method\nSuccess\nRate (%)") +
  scale_y_discrete("Method", labels = rev(parse(text = levels(testLabs$scenario))),
                   limits = rev) +
  labs(x = "Air Temperature (°C)") +
  theme(strip.background = element_blank())

```

## GPM IMERG comparison

```{r message = FALSE}

# Import data
gpm <- readRDS("../data/processed/mros_gpm_processed_2020_2021.RDS")

# Join the data
obsGPM <- left_join(obsPass,
                    gpm,
                    by = "id")


###############################################################################
# Summarize correct observations by temp bin

# Add GPM probability thresholds for rain, snow, mixed
prob_thresh_upper_rain = 100
prob_thresh_lower_rain = 50
prob_thresh_upper_snow = 50
prob_thresh_lower_snow = 0
prob_thresh_upper_mixed = prob_thresh_lower_rain
prob_thresh_lower_mixed = prob_thresh_upper_snow

# Add tair bin number and GPM phase
obsGPM <- obsGPM %>% 
  mutate(tair_bin_num = floor(tair) + 0.5,
         gpm_phase = case_when(gpm_prob <= prob_thresh_upper_snow &
                                 gpm_prob >= prob_thresh_lower_snow ~ "Snow",
                               gpm_prob <= prob_thresh_upper_rain &
                                 gpm_prob >= prob_thresh_lower_rain ~ "Rain",
                               gpm_prob < prob_thresh_upper_mixed &
                                 gpm_prob > prob_thresh_lower_mixed~ "Mixed"))

# Denote whether phase designation was correct or not
obsGPM_analyze <- bind_rows(
  select(obsGPM, tair_bin_num, phase, gpm_phase) %>% 
    mutate(eval_type = "all"),
  select(obsGPM, tair_bin_num, phase, gpm_phase) %>% 
    mutate(eval_type = "mixRain",
           phase = ifelse(phase == "Mixed", "Rain", as.character(phase)))
)

# Summarize over all obs
gpm_summary <- obsGPM_analyze %>% 
  group_by(eval_type) %>% 
  summarize(perf_pct = sum(phase == gpm_phase) / length(phase) * 100,
            snow_pct = sum(gpm_phase == "Snow") / length(phase) * 100,
            rain_pct = sum(gpm_phase == "Rain") / length(phase) * 100,
            mixed_pct = sum(gpm_phase == "Mixed") / length(phase) * 100,
            snow_bias_pct = (sum(gpm_phase == "Snow" ) / sum(phase == "Snow") - 1) * 100,
            rain_bias_pct = (sum(gpm_phase == "Rain" ) / sum(phase == "Rain") - 1) * 100,
            mixed_bias_pct = (sum(gpm_phase == "Mixed" ) / sum(phase == "Mixed") - 1) * 100)

# Summarize by tair bin
gpm_summary_byTair <- obsGPM_analyze %>% 
  group_by(eval_type, tair_bin_num) %>% 
  summarize(n = n(),
            perf_pct = sum(phase == gpm_phase) / length(phase) * 100,
            snow_pct = sum(gpm_phase == "Snow") / length(phase) * 100,
            rain_pct = sum(gpm_phase == "Rain") / length(phase) * 100,
            mixed_pct = sum(gpm_phase == "Mixed") / length(phase) * 100,
            snow_bias_pct = (sum(gpm_phase == "Snow" ) / sum(phase == "Snow") - 1) * 100,
            rain_bias_pct = (sum(gpm_phase == "Rain" ) / sum(phase == "Rain") - 1) * 100,
            mixed_bias_pct = (sum(gpm_phase == "Mixed" ) / sum(phase == "Mixed") - 1) * 100)

# Summarize
snowPct_gpm = round(filter(gpm_summary, eval_type == "mixRain")$snow_pct, 1)


```
Overall, the IMERG PLP product slightly underpredicted snowfall with an estimated frequency of `r snowPct_gpm`% compared to `r snowPct_obs`% as computed from the crowdsourced data. This gives the product a negative bias of `r round(filter(gpm_summary, eval_type == "mixRain")$snow_bias_pct, 1)`% in our study domain. As expected, the negative snow bias was complemented by a positive rain bias of `r round(filter(gpm_summary, eval_type == "mixRain")$rain_bias_pct, 1)`%. Again, the IMERG PLP does not consider mixed precipitation, so these comparisons are made after first converting all mixed observations to rainfall. In terms of performance, IMERG would rank 7th out of the precipitation phase partitioning methods previously examined with a success rate of `r round(filter(gpm_summary, eval_type == "mixRain")$perf_pct, 1)`% when compared to the citizen science observations. Similar to the other methods, the PLP decreased in performance at air temperatures near and above freezing.


```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(7,4.5)}
gpm_method_toPlot <- bind_rows(
  filter(gpm_summary_byTair, eval_type == "mixRain") %>% 
    select(perf_pct, snow_pct, tair_bin_num) %>% 
    mutate(method = "gpm"),
  filter(method_summary_byTair, eval_type == "mixRain" & scenario == "thresh_twet_0.5") %>% 
    select(perf_pct, snow_pct, snow_bias_pct, tair_bin_num) %>% 
    mutate(snow_pct = snow_pct + ((snow_bias_pct / 100) * snow_pct),
      method = "thresh_twet_0.5") %>% 
    select(-snow_bias_pct),
  obsPass %>% 
    mutate(tair_bin_num = floor(tair) + 0.5) %>% 
    group_by(tair_bin_num) %>% 
    summarize(snow_pct = sum(phase == "Snow") / n() * 100,
              method = "obs")
) %>% 
  pivot_longer(cols = perf_pct:snow_pct, values_to = "value", names_to = "metric")

ggplot(gpm_method_toPlot, aes(tair_bin_num, value, color = method, lty = metric)) +
  geom_line(lwd = 1) +
  labs(x = "Air Temperature (°C)",
       y = "Success Rate and Snowfall Frequency (%)") +
  scale_color_manual(values = c("deepskyblue3", "black", "aquamarine3"),
                     labels = c("IMERG", "Obs.", expression(T[w0.5])),
                     name = "Method") +
  scale_linetype_discrete(labels = c("Success\nRate", "Snowfall\nFrequency"),
                          name = "Metric") +
  theme(legend.position = c(0.8, 0.4))
```

```{r message = FALSE}
dpr <- readRDS("../data/processed/mros_dpr_processed_2020.RDS") %>% 
  pivot_longer(cols = c(dpr_hs_phase, dpr_ms_phase, dpr_ns_phase), 
               values_to = "phase_int", names_to = "instrument") %>% 
  mutate(phase_dpr = case_when(phase_int == 255 ~ "None",
                           phase_int <= 100 ~ "Snow",
                           phase_int > 100 & phase_int <= 200 ~ "Mixed",
                           phase_int > 200 ~ "Rain")) %>% 
  left_join(.,
            select(obsPass, id, phase, tair, twet, tdew, date), by = "id") %>% 
  filter(!is.na(phase)) # remove DPR data with no passing cit sci obs

dpr_summary <- left_join(
  dpr %>% 
    group_by(instrument) %>% 
    summarize(n = n(),
              n_valid = sum(phase_int != 255 & !is.na(phase_int))),
  dpr %>% 
    group_by(instrument) %>% 
    summarize(perf_pct = sum(phase == phase_dpr) / sum(phase_dpr != "None") * 100,
            snow_pct = sum(phase_dpr == "Snow") / sum(phase_dpr != "None") * 100,
            rain_pct = sum(phase_dpr == "Rain") / sum(phase_dpr != "None") * 100,
            mixed_pct = sum(phase_dpr == "Mixed") / sum(phase_dpr != "None") * 100,
            snow_bias_pct = (sum(phase_dpr == "Snow" ) / sum(phase == "Snow" & phase_dpr != "None") - 1) * 100,
            rain_bias_pct = (sum(phase_dpr == "Rain" ) / sum(phase == "Rain" & phase_dpr != "None") - 1) * 100,
            mixed_bias_pct = (sum(phase_dpr == "Mixed" ) / sum(phase == "Mixed" & phase_dpr != "None") - 1) * 100),
  by = "instrument"
)

dpr_date_min = min(dpr$date)
dpr_date_max = max(dpr$date)
n_obs_in_dpr_dates = length(filter(obsPass, date >= dpr_date_min & date <= dpr_date_max)$id)
```

Unfortunately, the DPR PNS product provided little useful information in our first study year. Between `r dpr_date_min` and `r dpr_date_max`, the first and last day of concurrent DPR overpasses that we examined, there were only `r length(unique(dpr$id))` citizen science observations that were submitted within a DPR grid cell. This is just `r round(length(unique(dpr$id))/n_obs_in_dpr_dates * 100, 1)`% of the `r n_obs_in_dpr_dates` total observations submitted in that time period. What's more, only `r dpr_summary %>% slice_max(n_valid, n = 1, with_ties = F) %>% pull(n_valid)` of the 90 DPR grid cells for the MS and NS instruments contained phase data. There were no valid HS data points and the remaining MS and NS grid cells contained NA values. All `r dpr_summary %>% slice_max(n_valid, n = 1, with_ties = F) %>% pull(n_valid)` MS and NS measurements were snow, giving the instrument a `r round(dpr_summary %>% slice_max(n_valid, n = 1, with_ties = F) %>% pull(perf_pct), 1)`% success rate, `r dpr_summary %>% slice_max(n_valid, n = 1, with_ties = F) %>% pull(snow_bias_pct)`% snow bias, and `r dpr_summary %>% slice_max(n_valid, n = 1, with_ties = F) %>% pull(rain_bias_pct)`% rain bias. Caution should be taken in interpreting these values because of the small sample size.

Plot of GPM IMERG PLP values by citizen science phase as a histogram.

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(7,4.5)}
ggplot(obsGPM, aes(gpm_prob, fill = phase)) +
  geom_histogram(color = "black") + 
  facet_wrap(~phase, scales = "free_y") + 
  phase_fill_scale +
  theme(legend.position = "none") +
  labs(x = "IMERG PLP (%)", y = "Count")
```

## Rain-snow line comparison

Import the data

```{r message = FALSE}

library(lubridate) # for datetime handling

# Import data
# gpm_rs <- readRDS("../data/processed/gpm_rain_snow_line_2020_2021.RDS") %>% 
#   mutate(datetime = with_tz(datetime, "Etc/Gmt+8")) # convert to PST

# Import freezing level radar and summarize to daily
flr_rs <- read.csv("../data/processed/CFF_2019_2021.csv", na.strings = " NaN") %>% 
  mutate(datetime = with_tz(as.POSIXct(paste0(year, "-", month, "-", day, " ", hour),
                               format = "%Y-%m-%d %H",
                               tz = "GMT"),
                            "Etc/Gmt+8"), # convert to PST
         rain_snow_line = BBH * 1000,
         date = as.Date(datetime, tz = "Etc/Gmt+8")) # convert from km to m
flr_rs_summary <- flr_rs %>% 
  filter(!is.na(rain_snow_line)) %>% 
  group_by(date) %>% 
  summarize(n = n(),
            rs_line = mean(rain_snow_line, na.rm = T),
            rs_line_sd = sd(rain_snow_line, na.rm = T),
            rs_line_min = min(rain_snow_line, na.rm = T),
            rs_line_max = max(rain_snow_line, na.rm = T),
            rs_line_range = rs_line_max - rs_line_min)

# Import observed rain-snow lines
obs_rs <- readRDS("../data/processed/mros_obs_rain_snow_line_2020-2021.RDS") %>% 
  mutate(datetime_min = as.POSIXct(paste0(date, " 08:00"), 
                                   tz = "Etc/Gmt+8"),
         datetime_max = as.POSIXct(paste0(date, " 20:00"), 
                                   tz = "Etc/Gmt+8"))

# Join data
#all <- left_join(gpm_rs, flr_rs, by = "datetime")
rs_line_daily <- left_join(obs_rs, flr_rs_summary, by = "date") %>% 
  filter(date %in% valid_dates)

# Get some info on the two datasets
rs_line_bias = round(with(rs_line_daily, mean(rs_line.y - rs_line.x, na.rm = T)), 1)
rs_line_r2 = round(summary(lm(rs_line.x ~ rs_line.y, rs_line_daily))$r.squared, 2)
rs_line_count = length(filter(rs_line_daily, !is.na(rs_line.y))$rs_line.y)
rs_line_hrly_range_av = mean(filter(flr_rs_summary, date %in% valid_dates)$rs_line_range)
rs_line_hrly_range_max = max(filter(flr_rs_summary, n > 5, date %in% valid_dates)$rs_line_range)
rs_line_hrly_range_min = min(filter(flr_rs_summary, n > 5, date %in% valid_dates)$rs_line_range)

```

Of the `r length(valid_dates)` days with a valid rain-snow line estimate from the citizen science data, there were `r rs_line_count` days with corresponding measurements of the brightband elevation from the freezing-level radar. There was a reasonable relationship between the two datasets with an r<sup>2</sup> of `r rs_line_r2` (Fig XXXXa). When comparing the daily data, there was a slight negative bias in the radar-derived values of `r rs_line_bias` m. This pattern can be seen in the example shown in Fig. XXXXb, where the hourly freezing-level radar measurements are typically below the daily estimates from the crowdsourced data. In general, the fluctuation in the brightband elevation was relatively small on days of overlapping data, with an average range of `r round(rs_line_hrly_range_av, 1)` m. The day with the greatest difference between minimum and maximum elevations was `r flr_rs_summary %>% slice(which(rs_line_range == rs_line_hrly_range_max)) %>% pull(date)` at `r rs_line_hrly_range_max` m  and the day with the minimum difference was `r flr_rs_summary %>% slice(which(rs_line_range == rs_line_hrly_range_min)) %>% pull(date)` at `r rs_line_hrly_range_min` m. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(9,4.5)}
min_datetime = as.POSIXct("2020-04-04 05:00", tz = "Etc/Gmt+8")
max_datetime = as.POSIXct("2020-04-07 00:00", tz = "Etc/Gmt+8")

plot_grid(
  ggplot(rs_line_daily, aes(rs_line.x, rs_line.y)) + 
    geom_point() + 
    geom_smooth(method = "lm", se = F, color = "darkblue") + 
    geom_abline(slope = 1, intercept = 0, lwd = 1, lty = "dashed", color = "gray") +
    annotate(geom = "text", x = 2000, y = 1650, 
             label = "Fit Line", color = "darkblue", hjust = 0) + 
    annotate(geom = "text", x = 2000, y = 2100, 
             label = "1:1 Line", color = "gray", hjust = 1) + 
    labs(x = "Cit. Sci. Rain-Snow Line Elev. (m)",
         y = "FLR Rain-Snow Line Elev. (m)"),
  filter(flr_rs, datetime >= min_datetime & 
         datetime <= max_datetime) %>% 
  ggplot() + 
  geom_point(aes(datetime, rain_snow_line), color = "darkorange3") + 
  ylim(900, 2000) + 
  geom_segment(data = filter(obs_rs, datetime_min >= min_datetime &
                               datetime_max <= max_datetime), 
               aes(x = datetime_min, y = rs_line, xend = datetime_max, yend = rs_line), 
               color = "darkorchid3", lwd = 1)  +
    annotate(geom = "text", x = as.POSIXct("2020-04-05 12:00", tz = "Etc/Gmt+8"), y = 1050, 
             label = "FLR", color = "darkorange3", hjust = 1) + 
    annotate(geom = "text", x = as.POSIXct("2020-04-06 14:00", tz = "Etc/Gmt+8"), y = 1700, 
             label = "Cit. Sci.", color = "darkorchid3", hjust = 0.5) + 
  labs(x = "Date",
       y = "Rain-Snow Line Elev. (m)"), 
  labels = "auto"
)
```

Plot an event:

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.dim= c(7,4.5)}
# Plot an event
# min_datetime = as.POSIXct("2020-04-04 05:00", tz = "Etc/Gmt+8")
# max_datetime = as.POSIXct("2020-04-07 00:00", tz = "Etc/Gmt+8")
# filter(all, datetime >= min_datetime & 
#          datetime <= max_datetime) %>% 
#   ggplot() + 
#   geom_line(aes(datetime, rs_line)) + 
#   geom_point(aes(datetime, rain_snow_line), color = "red") + 
#   ylim(900, 3000) + 
#   geom_segment(data = filter(obs_rs, datetime_min >= min_datetime &
#                                datetime_max <= max_datetime), 
#                aes(x = datetime_min, y = rs_line, xend = datetime_max, yend = rs_line), 
#                color = "purple", lwd = 1) + 
#   labs(x = "Datetime",
#        y = "Rain-Snow Line Elevation (m)")
```

# Discussion points

## Meteorological modeling accuracy
```{r}
tair_model_validation <- readRDS("../data/processed/tair_model_validation.RDS")
tair_mean_bias = round(with(tair_model_validation, mean(tair_idw_lapse_var - tair, na.rm = T)), 2)
tair_r2 = round(summary(lm(tair ~ tair_idw_lapse_var, tair_model_validation))$r.squared, 2)
```

We found a mean bias of `r tair_mean_bias`°C and an r<sup>2</sup> of `r tair_r2` when we compared the imputed air temperature values to the originally recorded observations. The error metrics for modeled wet bulb and dew point temperature and relative humidity were all similarly encouraging. However, we do note that small errors in the meteorological data can propogate into uncertainty in the amounts of rain versus snow predicted by the different precipitation phase partitioning methods. 


## Time of observations
We found that volunteers generally submitted observations during typical waking hours. `r round(length(filter(obsPass, hour >= 9 & hour <= 21)$id) / length(obsPass$id) * 100, 1)`% of reports arrived between the hours of 9AM and 9PM (0900 and 2100) Pacific Standard Time. 

```{r echo = FALSE, warning = FALSE, message = FALSE}
ggplot(obsPass, aes(hour)) + 
  geom_histogram(binwidth = 1, fill = "lavender", color = "black") +
  labs(x = "Hour of the Day", y = "Count")
```
